# 一些后端项目参考

1.
    1.  项目：高校就业信息分享平台

        *   内容模块：普通用户可以发布、搜索分享内容、删除自己发布的内容，可以对分享内容 进行评论、点赞；管理员用户可以发布置顶内容，可以对分享内容设置加精操作；

        *   通知和通信模块：用户可以接收到自己分享内容被点赞、被评论的通知；用户之间可以 进行即时通信以及查看历史聊天记录；

        *   用户模块：平台设置普通用户和管理员两种用户，基于 Apache Shiro 实现了权限控制， 实现了多重角色的权限管理，管理员用户可以查看 UV、DAU 的统计；
    2.  实习：大文件的秒传、断点续传、分片合并

*   小程序：“丹朱围棋”

*   Madtrace 为赛车爱好者所提供的一款软件，通过该软件，可以实时获取汽车通过OBD接口发送的车辆数据，并在手机上 进行显示。

*   实习：业务开发、需求评审

    *   独立的进行生产管理系统中的”订单加急”等重要功能的开发。

    *   利用线程池技术优化接口，加快接口速度。

*   桑乔拍卖平台

    *   利用 Spring Security + JWT 实现用户邮箱验证码登录与授权，登录成功后在 Redis 中储存用户登录凭证。

    *   Kafka异步完成邮箱发送、转账等耗时操作

    *   垂直分表

    *   redis缓存读多写少的数据

    *   生成唯一订单号

*   网络论坛项目

    *   登录

    *   统一异常处理

    *   redis

    *   kafka

*   在线学习项目

    *   分布式事务

    *   断点续传

    *   spring security

1.
    1.  安利日记（黑马点评）

    2.  球星卡出售小程序

        *   redis存储token

        *   购物车增删查改

        *   websocket实现来单提醒

*   短链接

*   IM即时通讯系统

    *   借助微信开放平台 API，实现 Channel 与OpenlD的关联，以带参二维码方式呈现微信扫码登录。

    *   结合 AOP 和封装 Starter，实现 Token 解析、请求上下文存储，黑名单拦截以及接口日志记录。

    *   基于模板方法模式，打造支持 Caffeine和Redis 混合的二级缓存框架。特别支持 Keys 的差集缓存，提升 易用性。

    *   针对全员群人数过万，写扩散系数爆炸，用户会话采用推拉结合的方式加载消息，类似 Feed 流。 针对消息、成员和会话列表，避免深翻页和频繁变动问题。引入游标翻页机制，约定前后端交互逻辑， 封装 Redis和 MySQL 两种数据源的翻页工具类，简化游标翻页实现。

    *   优化消息已读未读列表的数据库设计，仅记录用户阅读时间线，有效避免消息存储指数级增长。

    *   项目为集群架构，采用 RocketMQ 进行消息广播，Websocket 服务过滤连接消息，实现跨进程的消息 推送。

*   OJ在线判题系统

    *   使用代理模式对代码沙箱进行能力增强，统一实现了对代码沙箱调用前后的日志记录，减少重复代码。 为保证沙箱宿主机的稳定性，选用 Docker 隔离用户代码，使用 Docker Java 库创建容器隔离执行代码， 并通过 tty 和 Docker 进行传参交互，从而实现了更安全的代码沙箱。

    *   为防止判题操作执行时间较长，导致用户等待时间过长，带来不良体验，系统选用异步的方式，在题目 服务中将用户提交 id 发送给 RabbitMQ 消息队列，并通过 Direct 交换机转发给判题队列，由判题服务 进行消费，异步更新提交状态。

    *   为处理消息队列的消息重试，避免消息积压，基于RabbitMQ的死信队列实现了对超时、溢出、错误消 息的自动重试和路由管理。

    *   为防止某用户恶意占用系统资源，基于Redisson的Ratelimiter实现分布式限流，控制用户的提交频率。

*   （不太懂）该项目是面向快消产品公司的销售与费用商业计划管控系统，主要用于销售与费用投入方案录入， 并汇总出当前账期内各项计划指标数据的在线Excel文档；审批生成后的计划指标。

    *   通过模板方法模式和订阅发布模式（？）实现数据校验逻辑的解耦与主校验逻辑代码复用

    *   kafka提高响应速度

    *   多线程计算，提高速度

    *   慢SQL优化

    *   由于已有的网关是写死在配置文件中的，不利于后期动态的修改，通过使用Spring Cloud Gateway + MySql 方案，实现动态路由。

# Summary

*   大文件秒传、断点续传、分片

*   动态权限

*   kafka

*   分布式事务

*   websocket

*   二维码登录

*   模板方法模式：格式校验

*   慢SQL优化

*   nacos动态路由 <https://www.cnblogs.com/codelife3721/articles/17428373.html>

*   Sentinel限流（滑动窗口实现）

*   使用canal进行数据库监听，然后进行缓存更新，实现缓存一致性的同时实现了缓存与数据库操作的解耦。

*   12306

    *   使用责任链模式重构请求数据准确性检验，比如：查询购票、购买车票下单以及支付结果回调等业务。

    *   通过 RocketMQ 延时消息特性，完成用户购票 10 分钟后未支付情况下取消订单功能。

    *   封装缓存组件库避免注册用户时，用户名全局唯一带来的缓存穿透问题，减轻数据库访问压力。

    *   //使用 BinLog 配合 RocketMQ 消息队列完成 MySQL 数据库与 Redis 缓存之间的数据最终一致性。

    *   通过订单号和用户信息复合分片算法完成订单数据分库分表，支持订单号和用户查询维度。

    *   创建订单明细与乘车人的关联表，分库分表规则同订单，完成乘车人账号登录查询本人车票功能。

# finally

## 短链接

1.
    ### 原项目

*   布隆过滤器 + 双重判定锁

*   旁路缓存保证数据一致性

*   消息队列异步记录跳转日志

*   Redis解决消息重复消费

*   Redisson读写锁（为什么？Mysql本身不是有锁吗）

*   Sentinel限流

*   增加中间表，实现分表后多条件查询

1.
    ### 改进

*   改进布隆过滤器，缓存误判值，解决误判问题

*   布隆过滤器热重构、扩容，解决布隆过滤器无法删除、长度固定的问题

    *   异步拷贝到新的布隆过滤器

    *   记录拷贝期间的增量更新（存储到增量布隆过滤器和增量误判缓存）

    *   替换为新的布隆过滤器，然后阻塞式加入增量更新

*   把项目改造成微服务架构，通过网关实现短链接与服务实例IP的解耦，实现多实例部署和动态水平扩展

    *   原项目的短链接表存储的短链接是域名 + 唯一短链字符串，于是同一个短链接只能请求到同一个服务实例上，并且不能走网关。

*   动态路由

## 12306

1.
    ### 原项目

*   使用责任链模式重构请求数据准确性检验，比如：查询购票、购买车票下单以及支付结果回调等业务。

*   通过 RocketMQ 延时消息特性，完成用户购票 10 分钟后未支付情况下取消订单功能。

*   封装缓存组件库避免注册用户时，用户名全局唯一带来的缓存穿透问题，减轻数据库访问压力。

*   //使用 BinLog 配合 RocketMQ 消息队列完成 MySQL 数据库与 Redis 缓存之间的数据最终一致性。

*   通过订单号和用户信息复合分片算法完成订单数据分库分表，支持订单号和用户查询维度。

*   创建订单明细与乘车人的关联表，分库分表规则同订单，完成乘车人账号登录查询本人车票功能。

1.
    ### 改进

*   ~~冷热分离：创建时间在30天之前的已完成或已结束的订单放到冷数据库里（这样的数据是只读的），减少查询压力。冷热数据迁移采用canal监听binlog~~

*   采用redis集群 + 多级缓存解决热key问题（多级缓存如果采用本地缓存，如何多实例同步？）

    *   二级缓存：本地缓存 + redis集群缓存

        *   本地缓存：caffeine

            *   使用京东开源HotKey进行封装
        *   热key探测：京东开源HotKey

            *   架构：

                *   etcd：作为一个高性能的配置中心，可以以极小的资源占用，提供高效的监听订阅服务。主要用于存放规则配置，各worker的ip地址，以及探测出的热key、手工添加的热key等。

                *   client端：在我们的服务中添加的引用jar，引入后，就可以以便捷的方式去判断某key是否热key。同时，该jar完成了key上报、监听etcd里的rule变化、worker信息变化、热key变化，对热key进行本地caffeine缓存等。

                *   worker端是一个独立部署的Java程序，启动后会连接etcd，并定期上报自己的ip信息，供client端获取地址并进行长连接。之后，主要就是对各个client发来的待测key进行累加计算，当达到etcd里设定的rule阈值后，将热key推送到各个client。

                *   dashboard控制台：一个带可视化界面的Java程序，也是连接到etcd，之后在控制台设置各个APP的key规则，譬如2秒出现20次算热key。然后当worker探测出来热key后，会将key发往etcd，dashboard也会监听热key信息，进行入库保存记录。同时，dashboard也可以手工添加、删除热key，供各个client端监听。
            *   工作流程：

                *   client从etcd获取worker的ip地址，通过netty与worker建立长连接

                *   client端启动定时任务，每500毫秒向worker端批量发送一次待测的key到对应的worker，发送规则是发送的key进行hash然后对worker数量进行取余

                *   当热key探测出来后，可以选择进行本地存储，该框架采用caffein来存储
            *   注意：

                *   HotKey只会探测一个key是不是热key，但是不会关心value，我们需要自己主动维护value。当一个key是热key时，要主动设置这个key的value。

                *   为什么不给热key设置过期时间？

                    *   一般来说，设置过期时间的作用有两个：保证数据最终一致性、节省内存

                                    如果不设置过期时间，可以有这样一个例子：A线程读数据，发现缓存不存在，读数据库，然后B线程写数据库，然后删除缓存，然后A线程回写缓存，导致数据不一致。

                    *   但是在热key的场景下，最重要的是热key对于本地内存的命中率即高并发性能，而不是数据的一致性。实际上真实的12306的数据一致性就不是很高，经多次实测发现买票之后5分钟票数才更新

                    *   而节省内存方面，caffeine已经实现了自动内存淘汰，不会出现内存撑爆的情况

                        *   caffeine内存淘汰策略：
        *   数据同步：

            *   写数据：旁路缓存模式，写完数据库后把redis和本地缓存删除

            ```Java
            /**
            * 删除某key，会通知整个集群删除
            */
            public static void remove(String key) {
              getCache(key).delete(key);
              HotKeyPusher.remove(key);
            }
            ```

            *   读数据：

            暂时无法在飞书文档外展示此内容

            ```Java
            if (JdHotKeyStore.isHotKey(key)) {
                //注意是get，不是getValue。getValue会获取并上报，get是纯粹的本地获取              
                Object obj = JdHotKeyStore.get(key);              
                if(obj == null) {          
                    // 从redis里获取，旁路缓存策略
                    obj = getFromRedisCacheAside();        
                    JdHotKeyStore.smartSet(key, obj);              
                } else {                  
                    //使用缓存好的value即可              
                }         
            } else {
                JdHotKeyStore.remove(key);
                // 走redis
            }
            ```

